/*
 * generated by Xtext 2.11.0
 */
package org.xtext.example.mydsl1.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MyDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ScriptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.Script");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScriptKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cRunsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cAsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementsStatementParserRuleCall_4_0 = (RuleCall)cStatementsAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Script:
		//	'Script' name=Name
		//	'runs' 'as'
		//	statements+=Statement*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'Script' name=Name 'runs' 'as' statements+=Statement* 'end'
		public Group getGroup() { return cGroup; }
		
		//'Script'
		public Keyword getScriptKeyword_0() { return cScriptKeyword_0; }
		
		//name=Name
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//Name
		public RuleCall getNameNameParserRuleCall_1_0() { return cNameNameParserRuleCall_1_0; }
		
		//'runs'
		public Keyword getRunsKeyword_2() { return cRunsKeyword_2; }
		
		//'as'
		public Keyword getAsKeyword_3() { return cAsKeyword_3; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_4() { return cStatementsAssignment_4; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_4_0() { return cStatementsStatementParserRuleCall_4_0; }
		
		//'end'
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWhileStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRepeatStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cCommentParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTraceCommandParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cAtomicCommandParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cConstructionStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//Statement:
		//	IfStatement | WhileStatement | RepeatStatement | Comment | TraceCommand | AtomicCommand | ConstructionStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//IfStatement | WhileStatement | RepeatStatement | Comment | TraceCommand | AtomicCommand | ConstructionStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IfStatement
		public RuleCall getIfStatementParserRuleCall_0() { return cIfStatementParserRuleCall_0; }
		
		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_1() { return cWhileStatementParserRuleCall_1; }
		
		//RepeatStatement
		public RuleCall getRepeatStatementParserRuleCall_2() { return cRepeatStatementParserRuleCall_2; }
		
		//Comment
		public RuleCall getCommentParserRuleCall_3() { return cCommentParserRuleCall_3; }
		
		//TraceCommand
		public RuleCall getTraceCommandParserRuleCall_4() { return cTraceCommandParserRuleCall_4; }
		
		//AtomicCommand
		public RuleCall getAtomicCommandParserRuleCall_5() { return cAtomicCommandParserRuleCall_5; }
		
		//ConstructionStatement
		public RuleCall getConstructionStatementParserRuleCall_6() { return cConstructionStatementParserRuleCall_6; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNegatedExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBinaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cHeadingExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cWallAheadExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNormalExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Expression:
		//	NegatedExpression | BinaryExpression | HeadingExpression | WallAheadExpression | NormalExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//NegatedExpression | BinaryExpression | HeadingExpression | WallAheadExpression | NormalExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NegatedExpression
		public RuleCall getNegatedExpressionParserRuleCall_0() { return cNegatedExpressionParserRuleCall_0; }
		
		//BinaryExpression
		public RuleCall getBinaryExpressionParserRuleCall_1() { return cBinaryExpressionParserRuleCall_1; }
		
		//HeadingExpression
		public RuleCall getHeadingExpressionParserRuleCall_2() { return cHeadingExpressionParserRuleCall_2; }
		
		//WallAheadExpression
		public RuleCall getWallAheadExpressionParserRuleCall_3() { return cWallAheadExpressionParserRuleCall_3; }
		
		//NormalExpression
		public RuleCall getNormalExpressionParserRuleCall_4() { return cNormalExpressionParserRuleCall_4; }
	}
	public class NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.Name");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNameAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Name:
		//	{Name} ID;
		@Override public ParserRule getRule() { return rule; }
		
		//{Name} ID
		public Group getGroup() { return cGroup; }
		
		//{Name}
		public Action getNameAction_0() { return cNameAction_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
	}
	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIfExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIfExpressionExpressionParserRuleCall_1_0 = (RuleCall)cIfExpressionAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cElseKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Keyword cDoKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cStatements2Assignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cStatements2StatementParserRuleCall_4_2_0 = (RuleCall)cStatements2Assignment_4_2.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IfStatement:
		//	'if'
		//	ifExpression=Expression 'do'
		//	statements+=Statement* ('else' 'do' statements2+=Statement*)?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'if' ifExpression=Expression 'do' statements+=Statement* ('else' 'do' statements2+=Statement*)? 'end'
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//ifExpression=Expression
		public Assignment getIfExpressionAssignment_1() { return cIfExpressionAssignment_1; }
		
		//Expression
		public RuleCall getIfExpressionExpressionParserRuleCall_1_0() { return cIfExpressionExpressionParserRuleCall_1_0; }
		
		//'do'
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_3_0() { return cStatementsStatementParserRuleCall_3_0; }
		
		//('else' 'do' statements2+=Statement*)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'else'
		public Keyword getElseKeyword_4_0() { return cElseKeyword_4_0; }
		
		//'do'
		public Keyword getDoKeyword_4_1() { return cDoKeyword_4_1; }
		
		//statements2+=Statement*
		public Assignment getStatements2Assignment_4_2() { return cStatements2Assignment_4_2; }
		
		//Statement
		public RuleCall getStatements2StatementParserRuleCall_4_2_0() { return cStatements2StatementParserRuleCall_4_2_0; }
		
		//'end'
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
	}
	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cWhileExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhileExpressionExpressionParserRuleCall_1_0 = (RuleCall)cWhileExpressionAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//WhileStatement:
		//	'while'
		//	whileExpression=Expression 'do'
		//	statements+=Statement*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'while' whileExpression=Expression 'do' statements+=Statement* 'end'
		public Group getGroup() { return cGroup; }
		
		//'while'
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }
		
		//whileExpression=Expression
		public Assignment getWhileExpressionAssignment_1() { return cWhileExpressionAssignment_1; }
		
		//Expression
		public RuleCall getWhileExpressionExpressionParserRuleCall_1_0() { return cWhileExpressionExpressionParserRuleCall_1_0; }
		
		//'do'
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_3_0() { return cStatementsStatementParserRuleCall_3_0; }
		
		//'end'
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}
	public class RepeatStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.RepeatStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRepeatKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIntegerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIntegerIntegerParserRuleCall_1_0 = (RuleCall)cIntegerAssignment_1.eContents().get(0);
		private final Keyword cTimesKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//RepeatStatement:
		//	'repeat' integer=Integer 'times'
		//	statements+=Statement*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'repeat' integer=Integer 'times' statements+=Statement* 'end'
		public Group getGroup() { return cGroup; }
		
		//'repeat'
		public Keyword getRepeatKeyword_0() { return cRepeatKeyword_0; }
		
		//integer=Integer
		public Assignment getIntegerAssignment_1() { return cIntegerAssignment_1; }
		
		//Integer
		public RuleCall getIntegerIntegerParserRuleCall_1_0() { return cIntegerIntegerParserRuleCall_1_0; }
		
		//'times'
		public Keyword getTimesKeyword_2() { return cTimesKeyword_2; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_3_0() { return cStatementsStatementParserRuleCall_3_0; }
		
		//'end'
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}
	public class CommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.Comment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCommentAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCommentKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Comment:
		//	{Comment}
		//	'Comment';
		@Override public ParserRule getRule() { return rule; }
		
		//{Comment} 'Comment'
		public Group getGroup() { return cGroup; }
		
		//{Comment}
		public Action getCommentAction_0() { return cCommentAction_0; }
		
		//'Comment'
		public Keyword getCommentKeyword_1() { return cCommentKeyword_1; }
	}
	public class TraceCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.TraceCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTraceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStringAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStringStringExpressionParserRuleCall_1_0 = (RuleCall)cStringAssignment_1.eContents().get(0);
		
		//TraceCommand:
		//	'trace' string=StringExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'trace' string=StringExpression
		public Group getGroup() { return cGroup; }
		
		//'trace'
		public Keyword getTraceKeyword_0() { return cTraceKeyword_0; }
		
		//string=StringExpression
		public Assignment getStringAssignment_1() { return cStringAssignment_1; }
		
		//StringExpression
		public RuleCall getStringStringExpressionParserRuleCall_1_0() { return cStringStringExpressionParserRuleCall_1_0; }
	}
	public class AtomicCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.AtomicCommand");
		private final Assignment cLiteralAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cLiteralCommandLiteralEnumRuleCall_0 = (RuleCall)cLiteralAssignment.eContents().get(0);
		
		//AtomicCommand:
		//	literal=CommandLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//literal=CommandLiteral
		public Assignment getLiteralAssignment() { return cLiteralAssignment; }
		
		//CommandLiteral
		public RuleCall getLiteralCommandLiteralEnumRuleCall_0() { return cLiteralCommandLiteralEnumRuleCall_0; }
	}
	public class ConstructionStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.ConstructionStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCommandAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCommandGridLiteralEnumRuleCall_0_0 = (RuleCall)cCommandAssignment_0.eContents().get(0);
		private final Keyword cAtKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cRowKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIntegersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIntegersIntegerParserRuleCall_3_0 = (RuleCall)cIntegersAssignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cIntegersAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cIntegersIntegerParserRuleCall_6_0 = (RuleCall)cIntegersAssignment_6.eContents().get(0);
		
		//ConstructionStatement:
		//	command=GridLiteral
		//	'at' 'row:' integers+=Integer "," 'col:' integers+=Integer;
		@Override public ParserRule getRule() { return rule; }
		
		//command=GridLiteral 'at' 'row:' integers+=Integer "," 'col:' integers+=Integer
		public Group getGroup() { return cGroup; }
		
		//command=GridLiteral
		public Assignment getCommandAssignment_0() { return cCommandAssignment_0; }
		
		//GridLiteral
		public RuleCall getCommandGridLiteralEnumRuleCall_0_0() { return cCommandGridLiteralEnumRuleCall_0_0; }
		
		//'at'
		public Keyword getAtKeyword_1() { return cAtKeyword_1; }
		
		//'row:'
		public Keyword getRowKeyword_2() { return cRowKeyword_2; }
		
		//integers+=Integer
		public Assignment getIntegersAssignment_3() { return cIntegersAssignment_3; }
		
		//Integer
		public RuleCall getIntegersIntegerParserRuleCall_3_0() { return cIntegersIntegerParserRuleCall_3_0; }
		
		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }
		
		//'col:'
		public Keyword getColKeyword_5() { return cColKeyword_5; }
		
		//integers+=Integer
		public Assignment getIntegersAssignment_6() { return cIntegersAssignment_6; }
		
		//Integer
		public RuleCall getIntegersIntegerParserRuleCall_6_0() { return cIntegersIntegerParserRuleCall_6_0; }
	}
	public class NegatedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.NegatedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNegatedExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNegatedExpressionExpressionParserRuleCall_1_0 = (RuleCall)cNegatedExpressionAssignment_1.eContents().get(0);
		
		//NegatedExpression:
		//	'not' negatedExpression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'not' negatedExpression=Expression
		public Group getGroup() { return cGroup; }
		
		//'not'
		public Keyword getNotKeyword_0() { return cNotKeyword_0; }
		
		//negatedExpression=Expression
		public Assignment getNegatedExpressionAssignment_1() { return cNegatedExpressionAssignment_1; }
		
		//Expression
		public RuleCall getNegatedExpressionExpressionParserRuleCall_1_0() { return cNegatedExpressionExpressionParserRuleCall_1_0; }
	}
	public class BinaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.BinaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftExpressionExpressionParserRuleCall_1_0 = (RuleCall)cLeftExpressionAssignment_1.eContents().get(0);
		private final Assignment cOperatorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperatorOperatorLiteralEnumRuleCall_2_0 = (RuleCall)cOperatorAssignment_2.eContents().get(0);
		private final Assignment cRightExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightExpressionExpressionParserRuleCall_3_0 = (RuleCall)cRightExpressionAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BinaryExpression:
		//	'(' leftExpression=Expression operator=OperatorLiteral rightExpression=Expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' leftExpression=Expression operator=OperatorLiteral rightExpression=Expression ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//leftExpression=Expression
		public Assignment getLeftExpressionAssignment_1() { return cLeftExpressionAssignment_1; }
		
		//Expression
		public RuleCall getLeftExpressionExpressionParserRuleCall_1_0() { return cLeftExpressionExpressionParserRuleCall_1_0; }
		
		//operator=OperatorLiteral
		public Assignment getOperatorAssignment_2() { return cOperatorAssignment_2; }
		
		//OperatorLiteral
		public RuleCall getOperatorOperatorLiteralEnumRuleCall_2_0() { return cOperatorOperatorLiteralEnumRuleCall_2_0; }
		
		//rightExpression=Expression
		public Assignment getRightExpressionAssignment_3() { return cRightExpressionAssignment_3; }
		
		//Expression
		public RuleCall getRightExpressionExpressionParserRuleCall_3_0() { return cRightExpressionExpressionParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class HeadingExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.HeadingExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadingLiteralAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadingLiteralHeadingLiteralEnumRuleCall_0_0 = (RuleCall)cHeadingLiteralAssignment_0.eContents().get(0);
		private final Assignment cDirectionLiteralAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDirectionLiteralDirectionLiteralEnumRuleCall_1_0 = (RuleCall)cDirectionLiteralAssignment_1.eContents().get(0);
		
		//HeadingExpression:
		//	headingLiteral=HeadingLiteral
		//	directionLiteral=DirectionLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//headingLiteral=HeadingLiteral directionLiteral=DirectionLiteral
		public Group getGroup() { return cGroup; }
		
		//headingLiteral=HeadingLiteral
		public Assignment getHeadingLiteralAssignment_0() { return cHeadingLiteralAssignment_0; }
		
		//HeadingLiteral
		public RuleCall getHeadingLiteralHeadingLiteralEnumRuleCall_0_0() { return cHeadingLiteralHeadingLiteralEnumRuleCall_0_0; }
		
		//directionLiteral=DirectionLiteral
		public Assignment getDirectionLiteralAssignment_1() { return cDirectionLiteralAssignment_1; }
		
		//DirectionLiteral
		public RuleCall getDirectionLiteralDirectionLiteralEnumRuleCall_1_0() { return cDirectionLiteralDirectionLiteralEnumRuleCall_1_0; }
	}
	public class WallAheadExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.WallAheadExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cWallAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cWallWallLiteralEnumRuleCall_0_0 = (RuleCall)cWallAssignment_0.eContents().get(0);
		private final Assignment cAheadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAheadAheadLiteralEnumRuleCall_1_0 = (RuleCall)cAheadAssignment_1.eContents().get(0);
		
		//WallAheadExpression:
		//	wall=WallLiteral
		//	ahead=AheadLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//wall=WallLiteral ahead=AheadLiteral
		public Group getGroup() { return cGroup; }
		
		//wall=WallLiteral
		public Assignment getWallAssignment_0() { return cWallAssignment_0; }
		
		//WallLiteral
		public RuleCall getWallWallLiteralEnumRuleCall_0_0() { return cWallWallLiteralEnumRuleCall_0_0; }
		
		//ahead=AheadLiteral
		public Assignment getAheadAssignment_1() { return cAheadAssignment_1; }
		
		//AheadLiteral
		public RuleCall getAheadAheadLiteralEnumRuleCall_1_0() { return cAheadAheadLiteralEnumRuleCall_1_0; }
	}
	public class NormalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.NormalExpression");
		private final Assignment cLiteralAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cLiteralNormalExpressionLiteralEnumRuleCall_0 = (RuleCall)cLiteralAssignment.eContents().get(0);
		
		//NormalExpression:
		//	literal=NormalExpressionLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//literal=NormalExpressionLiteral
		public Assignment getLiteralAssignment() { return cLiteralAssignment; }
		
		//NormalExpressionLiteral
		public RuleCall getLiteralNormalExpressionLiteralEnumRuleCall_0() { return cLiteralNormalExpressionLiteralEnumRuleCall_0; }
	}
	public class IntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.Integer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntegerAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Integer:
		//	{Integer} INT;
		@Override public ParserRule getRule() { return rule; }
		
		//{Integer} INT
		public Group getGroup() { return cGroup; }
		
		//{Integer}
		public Action getIntegerAction_0() { return cIntegerAction_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	public class StringExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.StringExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStringExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//StringExpression:
		//	{StringExpression} STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//{StringExpression} STRING
		public Group getGroup() { return cGroup; }
		
		//{StringExpression}
		public Action getStringExpressionAction_0() { return cStringExpressionAction_0; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1() { return cSTRINGTerminalRuleCall_1; }
	}
	
	public class OperatorLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.OperatorLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAndEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAndAndKeyword_0_0 = (Keyword)cAndEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOrEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOrOrKeyword_1_0 = (Keyword)cOrEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum OperatorLiteral:
		//	and | or;
		public EnumRule getRule() { return rule; }
		
		//and | or
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//and
		public EnumLiteralDeclaration getAndEnumLiteralDeclaration_0() { return cAndEnumLiteralDeclaration_0; }
		
		//'and'
		public Keyword getAndAndKeyword_0_0() { return cAndAndKeyword_0_0; }
		
		//or
		public EnumLiteralDeclaration getOrEnumLiteralDeclaration_1() { return cOrEnumLiteralDeclaration_1; }
		
		//'or'
		public Keyword getOrOrKeyword_1_0() { return cOrOrKeyword_1_0; }
	}
	public class HeadingLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.HeadingLiteral");
		private final EnumLiteralDeclaration cHeadingEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cHeadingHeadingKeyword_0 = (Keyword)cHeadingEnumLiteralDeclaration.eContents().get(0);
		
		//enum HeadingLiteral:
		//	heading;
		public EnumRule getRule() { return rule; }
		
		//heading
		public EnumLiteralDeclaration getHeadingEnumLiteralDeclaration() { return cHeadingEnumLiteralDeclaration; }
		
		//'heading'
		public Keyword getHeadingHeadingKeyword_0() { return cHeadingHeadingKeyword_0; }
	}
	public class DirectionLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.DirectionLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNorthEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNorthNorthKeyword_0_0 = (Keyword)cNorthEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSouthEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSouthSouthKeyword_1_0 = (Keyword)cSouthEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEastEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEastEastKeyword_2_0 = (Keyword)cEastEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cWestEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cWestWestKeyword_3_0 = (Keyword)cWestEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum DirectionLiteral:
		//	north | south | east | west;
		public EnumRule getRule() { return rule; }
		
		//north | south | east | west
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//north
		public EnumLiteralDeclaration getNorthEnumLiteralDeclaration_0() { return cNorthEnumLiteralDeclaration_0; }
		
		//'north'
		public Keyword getNorthNorthKeyword_0_0() { return cNorthNorthKeyword_0_0; }
		
		//south
		public EnumLiteralDeclaration getSouthEnumLiteralDeclaration_1() { return cSouthEnumLiteralDeclaration_1; }
		
		//'south'
		public Keyword getSouthSouthKeyword_1_0() { return cSouthSouthKeyword_1_0; }
		
		//east
		public EnumLiteralDeclaration getEastEnumLiteralDeclaration_2() { return cEastEnumLiteralDeclaration_2; }
		
		//'east'
		public Keyword getEastEastKeyword_2_0() { return cEastEastKeyword_2_0; }
		
		//west
		public EnumLiteralDeclaration getWestEnumLiteralDeclaration_3() { return cWestEnumLiteralDeclaration_3; }
		
		//'west'
		public Keyword getWestWestKeyword_3_0() { return cWestWestKeyword_3_0; }
	}
	public class WallLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.WallLiteral");
		private final EnumLiteralDeclaration cWallEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cWallWallKeyword_0 = (Keyword)cWallEnumLiteralDeclaration.eContents().get(0);
		
		//enum WallLiteral:
		//	wall;
		public EnumRule getRule() { return rule; }
		
		//wall
		public EnumLiteralDeclaration getWallEnumLiteralDeclaration() { return cWallEnumLiteralDeclaration; }
		
		//'wall'
		public Keyword getWallWallKeyword_0() { return cWallWallKeyword_0; }
	}
	public class AheadLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.AheadLiteral");
		private final EnumLiteralDeclaration cAheadEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cAheadAheadKeyword_0 = (Keyword)cAheadEnumLiteralDeclaration.eContents().get(0);
		
		//enum AheadLiteral:
		//	ahead;
		public EnumRule getRule() { return rule; }
		
		//ahead
		public EnumLiteralDeclaration getAheadEnumLiteralDeclaration() { return cAheadEnumLiteralDeclaration; }
		
		//'ahead'
		public Keyword getAheadAheadKeyword_0() { return cAheadAheadKeyword_0; }
	}
	public class NormalExpressionLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.NormalExpressionLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFullEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFullFullKeyword_0_0 = (Keyword)cFullEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMarkEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMarkMarkKeyword_1_0 = (Keyword)cMarkEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum NormalExpressionLiteral:
		//	full | mark;
		public EnumRule getRule() { return rule; }
		
		//full | mark
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//full
		public EnumLiteralDeclaration getFullEnumLiteralDeclaration_0() { return cFullEnumLiteralDeclaration_0; }
		
		//'full'
		public Keyword getFullFullKeyword_0_0() { return cFullFullKeyword_0_0; }
		
		//mark
		public EnumLiteralDeclaration getMarkEnumLiteralDeclaration_1() { return cMarkEnumLiteralDeclaration_1; }
		
		//'mark'
		public Keyword getMarkMarkKeyword_1_0() { return cMarkMarkKeyword_1_0; }
	}
	public class TraceLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.TraceLiteral");
		private final EnumLiteralDeclaration cTraceEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cTraceTraceKeyword_0 = (Keyword)cTraceEnumLiteralDeclaration.eContents().get(0);
		
		//enum TraceLiteral:
		//	trace;
		public EnumRule getRule() { return rule; }
		
		//trace
		public EnumLiteralDeclaration getTraceEnumLiteralDeclaration() { return cTraceEnumLiteralDeclaration; }
		
		//'trace'
		public Keyword getTraceTraceKeyword_0() { return cTraceTraceKeyword_0; }
	}
	public class CommandLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.CommandLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cStepEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cStepStepKeyword_0_0 = (Keyword)cStepEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cTurnLeftEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cTurnLeftTurnLeftKeyword_1_0 = (Keyword)cTurnLeftEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDropEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDropDropKeyword_2_0 = (Keyword)cDropEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cPickEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cPickPickKeyword_3_0 = (Keyword)cPickEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum CommandLiteral:
		//	step | turnLeft | drop | pick;
		public EnumRule getRule() { return rule; }
		
		//step | turnLeft | drop | pick
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//step
		public EnumLiteralDeclaration getStepEnumLiteralDeclaration_0() { return cStepEnumLiteralDeclaration_0; }
		
		//'step'
		public Keyword getStepStepKeyword_0_0() { return cStepStepKeyword_0_0; }
		
		//turnLeft
		public EnumLiteralDeclaration getTurnLeftEnumLiteralDeclaration_1() { return cTurnLeftEnumLiteralDeclaration_1; }
		
		//'turnLeft'
		public Keyword getTurnLeftTurnLeftKeyword_1_0() { return cTurnLeftTurnLeftKeyword_1_0; }
		
		//drop
		public EnumLiteralDeclaration getDropEnumLiteralDeclaration_2() { return cDropEnumLiteralDeclaration_2; }
		
		//'drop'
		public Keyword getDropDropKeyword_2_0() { return cDropDropKeyword_2_0; }
		
		//pick
		public EnumLiteralDeclaration getPickEnumLiteralDeclaration_3() { return cPickEnumLiteralDeclaration_3; }
		
		//'pick'
		public Keyword getPickPickKeyword_3_0() { return cPickPickKeyword_3_0; }
	}
	public class GridLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MyDsl.GridLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBuildWallEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBuildWallBuildWallKeyword_0_0 = (Keyword)cBuildWallEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDestroyWallEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDestroyWallDestroyWallKeyword_1_0 = (Keyword)cDestroyWallEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPickMarkEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPickMarkPickMarkKeyword_2_0 = (Keyword)cPickMarkEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cDropMarkEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cDropMarkDropMarkKeyword_3_0 = (Keyword)cDropMarkEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum GridLiteral:
		//	buildWall | destroyWall | pickMark | dropMark;
		public EnumRule getRule() { return rule; }
		
		//buildWall | destroyWall | pickMark | dropMark
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//buildWall
		public EnumLiteralDeclaration getBuildWallEnumLiteralDeclaration_0() { return cBuildWallEnumLiteralDeclaration_0; }
		
		//'buildWall'
		public Keyword getBuildWallBuildWallKeyword_0_0() { return cBuildWallBuildWallKeyword_0_0; }
		
		//destroyWall
		public EnumLiteralDeclaration getDestroyWallEnumLiteralDeclaration_1() { return cDestroyWallEnumLiteralDeclaration_1; }
		
		//'destroyWall'
		public Keyword getDestroyWallDestroyWallKeyword_1_0() { return cDestroyWallDestroyWallKeyword_1_0; }
		
		//pickMark
		public EnumLiteralDeclaration getPickMarkEnumLiteralDeclaration_2() { return cPickMarkEnumLiteralDeclaration_2; }
		
		//'pickMark'
		public Keyword getPickMarkPickMarkKeyword_2_0() { return cPickMarkPickMarkKeyword_2_0; }
		
		//dropMark
		public EnumLiteralDeclaration getDropMarkEnumLiteralDeclaration_3() { return cDropMarkEnumLiteralDeclaration_3; }
		
		//'dropMark'
		public Keyword getDropMarkDropMarkKeyword_3_0() { return cDropMarkDropMarkKeyword_3_0; }
	}
	
	private final ScriptElements pScript;
	private final StatementElements pStatement;
	private final ExpressionElements pExpression;
	private final NameElements pName;
	private final IfStatementElements pIfStatement;
	private final WhileStatementElements pWhileStatement;
	private final RepeatStatementElements pRepeatStatement;
	private final CommentElements pComment;
	private final TraceCommandElements pTraceCommand;
	private final AtomicCommandElements pAtomicCommand;
	private final ConstructionStatementElements pConstructionStatement;
	private final NegatedExpressionElements pNegatedExpression;
	private final BinaryExpressionElements pBinaryExpression;
	private final HeadingExpressionElements pHeadingExpression;
	private final WallAheadExpressionElements pWallAheadExpression;
	private final NormalExpressionElements pNormalExpression;
	private final OperatorLiteralElements eOperatorLiteral;
	private final HeadingLiteralElements eHeadingLiteral;
	private final DirectionLiteralElements eDirectionLiteral;
	private final WallLiteralElements eWallLiteral;
	private final AheadLiteralElements eAheadLiteral;
	private final NormalExpressionLiteralElements eNormalExpressionLiteral;
	private final IntegerElements pInteger;
	private final TraceLiteralElements eTraceLiteral;
	private final StringExpressionElements pStringExpression;
	private final CommandLiteralElements eCommandLiteral;
	private final GridLiteralElements eGridLiteral;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MyDslGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pScript = new ScriptElements();
		this.pStatement = new StatementElements();
		this.pExpression = new ExpressionElements();
		this.pName = new NameElements();
		this.pIfStatement = new IfStatementElements();
		this.pWhileStatement = new WhileStatementElements();
		this.pRepeatStatement = new RepeatStatementElements();
		this.pComment = new CommentElements();
		this.pTraceCommand = new TraceCommandElements();
		this.pAtomicCommand = new AtomicCommandElements();
		this.pConstructionStatement = new ConstructionStatementElements();
		this.pNegatedExpression = new NegatedExpressionElements();
		this.pBinaryExpression = new BinaryExpressionElements();
		this.pHeadingExpression = new HeadingExpressionElements();
		this.pWallAheadExpression = new WallAheadExpressionElements();
		this.pNormalExpression = new NormalExpressionElements();
		this.eOperatorLiteral = new OperatorLiteralElements();
		this.eHeadingLiteral = new HeadingLiteralElements();
		this.eDirectionLiteral = new DirectionLiteralElements();
		this.eWallLiteral = new WallLiteralElements();
		this.eAheadLiteral = new AheadLiteralElements();
		this.eNormalExpressionLiteral = new NormalExpressionLiteralElements();
		this.pInteger = new IntegerElements();
		this.eTraceLiteral = new TraceLiteralElements();
		this.pStringExpression = new StringExpressionElements();
		this.eCommandLiteral = new CommandLiteralElements();
		this.eGridLiteral = new GridLiteralElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.mydsl1.MyDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Script:
	//	'Script' name=Name
	//	'runs' 'as'
	//	statements+=Statement*
	//	'end';
	public ScriptElements getScriptAccess() {
		return pScript;
	}
	
	public ParserRule getScriptRule() {
		return getScriptAccess().getRule();
	}
	
	//Statement:
	//	IfStatement | WhileStatement | RepeatStatement | Comment | TraceCommand | AtomicCommand | ConstructionStatement;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//Expression:
	//	NegatedExpression | BinaryExpression | HeadingExpression | WallAheadExpression | NormalExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Name:
	//	{Name} ID;
	public NameElements getNameAccess() {
		return pName;
	}
	
	public ParserRule getNameRule() {
		return getNameAccess().getRule();
	}
	
	//IfStatement:
	//	'if'
	//	ifExpression=Expression 'do'
	//	statements+=Statement* ('else' 'do' statements2+=Statement*)?
	//	'end';
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}
	
	//WhileStatement:
	//	'while'
	//	whileExpression=Expression 'do'
	//	statements+=Statement*
	//	'end';
	public WhileStatementElements getWhileStatementAccess() {
		return pWhileStatement;
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}
	
	//RepeatStatement:
	//	'repeat' integer=Integer 'times'
	//	statements+=Statement*
	//	'end';
	public RepeatStatementElements getRepeatStatementAccess() {
		return pRepeatStatement;
	}
	
	public ParserRule getRepeatStatementRule() {
		return getRepeatStatementAccess().getRule();
	}
	
	//Comment:
	//	{Comment}
	//	'Comment';
	public CommentElements getCommentAccess() {
		return pComment;
	}
	
	public ParserRule getCommentRule() {
		return getCommentAccess().getRule();
	}
	
	//TraceCommand:
	//	'trace' string=StringExpression;
	public TraceCommandElements getTraceCommandAccess() {
		return pTraceCommand;
	}
	
	public ParserRule getTraceCommandRule() {
		return getTraceCommandAccess().getRule();
	}
	
	//AtomicCommand:
	//	literal=CommandLiteral;
	public AtomicCommandElements getAtomicCommandAccess() {
		return pAtomicCommand;
	}
	
	public ParserRule getAtomicCommandRule() {
		return getAtomicCommandAccess().getRule();
	}
	
	//ConstructionStatement:
	//	command=GridLiteral
	//	'at' 'row:' integers+=Integer "," 'col:' integers+=Integer;
	public ConstructionStatementElements getConstructionStatementAccess() {
		return pConstructionStatement;
	}
	
	public ParserRule getConstructionStatementRule() {
		return getConstructionStatementAccess().getRule();
	}
	
	//NegatedExpression:
	//	'not' negatedExpression=Expression;
	public NegatedExpressionElements getNegatedExpressionAccess() {
		return pNegatedExpression;
	}
	
	public ParserRule getNegatedExpressionRule() {
		return getNegatedExpressionAccess().getRule();
	}
	
	//BinaryExpression:
	//	'(' leftExpression=Expression operator=OperatorLiteral rightExpression=Expression ')';
	public BinaryExpressionElements getBinaryExpressionAccess() {
		return pBinaryExpression;
	}
	
	public ParserRule getBinaryExpressionRule() {
		return getBinaryExpressionAccess().getRule();
	}
	
	//HeadingExpression:
	//	headingLiteral=HeadingLiteral
	//	directionLiteral=DirectionLiteral;
	public HeadingExpressionElements getHeadingExpressionAccess() {
		return pHeadingExpression;
	}
	
	public ParserRule getHeadingExpressionRule() {
		return getHeadingExpressionAccess().getRule();
	}
	
	//WallAheadExpression:
	//	wall=WallLiteral
	//	ahead=AheadLiteral;
	public WallAheadExpressionElements getWallAheadExpressionAccess() {
		return pWallAheadExpression;
	}
	
	public ParserRule getWallAheadExpressionRule() {
		return getWallAheadExpressionAccess().getRule();
	}
	
	//NormalExpression:
	//	literal=NormalExpressionLiteral;
	public NormalExpressionElements getNormalExpressionAccess() {
		return pNormalExpression;
	}
	
	public ParserRule getNormalExpressionRule() {
		return getNormalExpressionAccess().getRule();
	}
	
	//enum OperatorLiteral:
	//	and | or;
	public OperatorLiteralElements getOperatorLiteralAccess() {
		return eOperatorLiteral;
	}
	
	public EnumRule getOperatorLiteralRule() {
		return getOperatorLiteralAccess().getRule();
	}
	
	//enum HeadingLiteral:
	//	heading;
	public HeadingLiteralElements getHeadingLiteralAccess() {
		return eHeadingLiteral;
	}
	
	public EnumRule getHeadingLiteralRule() {
		return getHeadingLiteralAccess().getRule();
	}
	
	//enum DirectionLiteral:
	//	north | south | east | west;
	public DirectionLiteralElements getDirectionLiteralAccess() {
		return eDirectionLiteral;
	}
	
	public EnumRule getDirectionLiteralRule() {
		return getDirectionLiteralAccess().getRule();
	}
	
	//enum WallLiteral:
	//	wall;
	public WallLiteralElements getWallLiteralAccess() {
		return eWallLiteral;
	}
	
	public EnumRule getWallLiteralRule() {
		return getWallLiteralAccess().getRule();
	}
	
	//enum AheadLiteral:
	//	ahead;
	public AheadLiteralElements getAheadLiteralAccess() {
		return eAheadLiteral;
	}
	
	public EnumRule getAheadLiteralRule() {
		return getAheadLiteralAccess().getRule();
	}
	
	//enum NormalExpressionLiteral:
	//	full | mark;
	public NormalExpressionLiteralElements getNormalExpressionLiteralAccess() {
		return eNormalExpressionLiteral;
	}
	
	public EnumRule getNormalExpressionLiteralRule() {
		return getNormalExpressionLiteralAccess().getRule();
	}
	
	//Integer:
	//	{Integer} INT;
	public IntegerElements getIntegerAccess() {
		return pInteger;
	}
	
	public ParserRule getIntegerRule() {
		return getIntegerAccess().getRule();
	}
	
	//enum TraceLiteral:
	//	trace;
	public TraceLiteralElements getTraceLiteralAccess() {
		return eTraceLiteral;
	}
	
	public EnumRule getTraceLiteralRule() {
		return getTraceLiteralAccess().getRule();
	}
	
	//StringExpression:
	//	{StringExpression} STRING;
	public StringExpressionElements getStringExpressionAccess() {
		return pStringExpression;
	}
	
	public ParserRule getStringExpressionRule() {
		return getStringExpressionAccess().getRule();
	}
	
	//enum CommandLiteral:
	//	step | turnLeft | drop | pick;
	public CommandLiteralElements getCommandLiteralAccess() {
		return eCommandLiteral;
	}
	
	public EnumRule getCommandLiteralRule() {
		return getCommandLiteralAccess().getRule();
	}
	
	//enum GridLiteral:
	//	buildWall | destroyWall | pickMark | dropMark;
	public GridLiteralElements getGridLiteralAccess() {
		return eGridLiteral;
	}
	
	public EnumRule getGridLiteralRule() {
		return getGridLiteralAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
