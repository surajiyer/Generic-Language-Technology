/*
 * generated by Xtext 2.12.0
 */
package nl.tue.robot.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class RobotGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ScriptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.Script");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cScriptAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cScriptKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cRunsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cAsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCommandAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCommandStatementParserRuleCall_5_0 = (RuleCall)cCommandAssignment_5.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Script:
		//	{Script}
		//	'Script' name=ID 'runs' 'as'
		//	command+=Statement*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//{Script} 'Script' name=ID 'runs' 'as' command+=Statement* 'end'
		public Group getGroup() { return cGroup; }
		
		//{Script}
		public Action getScriptAction_0() { return cScriptAction_0; }
		
		//'Script'
		public Keyword getScriptKeyword_1() { return cScriptKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//'runs'
		public Keyword getRunsKeyword_3() { return cRunsKeyword_3; }
		
		//'as'
		public Keyword getAsKeyword_4() { return cAsKeyword_4; }
		
		//command+=Statement*
		public Assignment getCommandAssignment_5() { return cCommandAssignment_5; }
		
		//Statement
		public RuleCall getCommandStatementParserRuleCall_5_0() { return cCommandStatementParserRuleCall_5_0; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWhileStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRepeatStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cCommentParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTraceCommandParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cAtomicCommandParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cConstructionStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//Statement:
		//	IfStatement | WhileStatement | RepeatStatement | Comment | TraceCommand | AtomicCommand | ConstructionStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//IfStatement | WhileStatement | RepeatStatement | Comment | TraceCommand | AtomicCommand | ConstructionStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IfStatement
		public RuleCall getIfStatementParserRuleCall_0() { return cIfStatementParserRuleCall_0; }
		
		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_1() { return cWhileStatementParserRuleCall_1; }
		
		//RepeatStatement
		public RuleCall getRepeatStatementParserRuleCall_2() { return cRepeatStatementParserRuleCall_2; }
		
		//Comment
		public RuleCall getCommentParserRuleCall_3() { return cCommentParserRuleCall_3; }
		
		//TraceCommand
		public RuleCall getTraceCommandParserRuleCall_4() { return cTraceCommandParserRuleCall_4; }
		
		//AtomicCommand
		public RuleCall getAtomicCommandParserRuleCall_5() { return cAtomicCommandParserRuleCall_5; }
		
		//ConstructionStatement
		public RuleCall getConstructionStatementParserRuleCall_6() { return cConstructionStatementParserRuleCall_6; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNegatedExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBinaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cHeadingExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cWallAheadExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNormalExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Expression:
		//	NegatedExpression | BinaryExpression | HeadingExpression | WallAheadExpression | NormalExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//NegatedExpression | BinaryExpression | HeadingExpression | WallAheadExpression | NormalExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NegatedExpression
		public RuleCall getNegatedExpressionParserRuleCall_0() { return cNegatedExpressionParserRuleCall_0; }
		
		//BinaryExpression
		public RuleCall getBinaryExpressionParserRuleCall_1() { return cBinaryExpressionParserRuleCall_1; }
		
		//HeadingExpression
		public RuleCall getHeadingExpressionParserRuleCall_2() { return cHeadingExpressionParserRuleCall_2; }
		
		//WallAheadExpression
		public RuleCall getWallAheadExpressionParserRuleCall_3() { return cWallAheadExpressionParserRuleCall_3; }
		
		//NormalExpression
		public RuleCall getNormalExpressionParserRuleCall_4() { return cNormalExpressionParserRuleCall_4; }
	}
	public class NegatedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.NegatedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNegatedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNegatedExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNegatedExpressionExpressionParserRuleCall_2_0 = (RuleCall)cNegatedExpressionAssignment_2.eContents().get(0);
		
		//NegatedExpression Expression:
		//	{NegatedExpression}
		//	'not' negatedExpression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{NegatedExpression} 'not' negatedExpression=Expression
		public Group getGroup() { return cGroup; }
		
		//{NegatedExpression}
		public Action getNegatedExpressionAction_0() { return cNegatedExpressionAction_0; }
		
		//'not'
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
		
		//negatedExpression=Expression
		public Assignment getNegatedExpressionAssignment_2() { return cNegatedExpressionAssignment_2; }
		
		//Expression
		public RuleCall getNegatedExpressionExpressionParserRuleCall_2_0() { return cNegatedExpressionExpressionParserRuleCall_2_0; }
	}
	public class BinaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.BinaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBinaryExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftExpressionExpressionParserRuleCall_2_0 = (RuleCall)cLeftExpressionAssignment_2.eContents().get(0);
		private final Assignment cOperatorAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOperatorOperatorLiteralEnumRuleCall_3_0 = (RuleCall)cOperatorAssignment_3.eContents().get(0);
		private final Assignment cRightExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightExpressionExpressionParserRuleCall_4_0 = (RuleCall)cRightExpressionAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//BinaryExpression Expression:
		//	{BinaryExpression}
		//	'(' leftExpression=Expression operator=OperatorLiteral rightExpression=Expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{BinaryExpression} '(' leftExpression=Expression operator=OperatorLiteral rightExpression=Expression ')'
		public Group getGroup() { return cGroup; }
		
		//{BinaryExpression}
		public Action getBinaryExpressionAction_0() { return cBinaryExpressionAction_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//leftExpression=Expression
		public Assignment getLeftExpressionAssignment_2() { return cLeftExpressionAssignment_2; }
		
		//Expression
		public RuleCall getLeftExpressionExpressionParserRuleCall_2_0() { return cLeftExpressionExpressionParserRuleCall_2_0; }
		
		//operator=OperatorLiteral
		public Assignment getOperatorAssignment_3() { return cOperatorAssignment_3; }
		
		//OperatorLiteral
		public RuleCall getOperatorOperatorLiteralEnumRuleCall_3_0() { return cOperatorOperatorLiteralEnumRuleCall_3_0; }
		
		//rightExpression=Expression
		public Assignment getRightExpressionAssignment_4() { return cRightExpressionAssignment_4; }
		
		//Expression
		public RuleCall getRightExpressionExpressionParserRuleCall_4_0() { return cRightExpressionExpressionParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class HeadingExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.HeadingExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cHeadingExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cHeadingLiteralAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadingLiteralHeadingLiteralEnumRuleCall_1_0 = (RuleCall)cHeadingLiteralAssignment_1.eContents().get(0);
		private final Assignment cDirectionLiteralAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDirectionLiteralDirectionLiteralEnumRuleCall_2_0 = (RuleCall)cDirectionLiteralAssignment_2.eContents().get(0);
		
		//HeadingExpression Expression:
		//	{HeadingExpression} headingLiteral=HeadingLiteral directionLiteral=DirectionLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//{HeadingExpression} headingLiteral=HeadingLiteral directionLiteral=DirectionLiteral
		public Group getGroup() { return cGroup; }
		
		//{HeadingExpression}
		public Action getHeadingExpressionAction_0() { return cHeadingExpressionAction_0; }
		
		//headingLiteral=HeadingLiteral
		public Assignment getHeadingLiteralAssignment_1() { return cHeadingLiteralAssignment_1; }
		
		//HeadingLiteral
		public RuleCall getHeadingLiteralHeadingLiteralEnumRuleCall_1_0() { return cHeadingLiteralHeadingLiteralEnumRuleCall_1_0; }
		
		//directionLiteral=DirectionLiteral
		public Assignment getDirectionLiteralAssignment_2() { return cDirectionLiteralAssignment_2; }
		
		//DirectionLiteral
		public RuleCall getDirectionLiteralDirectionLiteralEnumRuleCall_2_0() { return cDirectionLiteralDirectionLiteralEnumRuleCall_2_0; }
	}
	public class WallAheadExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.WallAheadExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWallAheadExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cWallAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWallWallLiteralEnumRuleCall_1_0 = (RuleCall)cWallAssignment_1.eContents().get(0);
		private final Assignment cAheadAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAheadAheadLiteralEnumRuleCall_2_0 = (RuleCall)cAheadAssignment_2.eContents().get(0);
		
		//WallAheadExpression Expression:
		//	{WallAheadExpression} wall=WallLiteral ahead=AheadLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//{WallAheadExpression} wall=WallLiteral ahead=AheadLiteral
		public Group getGroup() { return cGroup; }
		
		//{WallAheadExpression}
		public Action getWallAheadExpressionAction_0() { return cWallAheadExpressionAction_0; }
		
		//wall=WallLiteral
		public Assignment getWallAssignment_1() { return cWallAssignment_1; }
		
		//WallLiteral
		public RuleCall getWallWallLiteralEnumRuleCall_1_0() { return cWallWallLiteralEnumRuleCall_1_0; }
		
		//ahead=AheadLiteral
		public Assignment getAheadAssignment_2() { return cAheadAssignment_2; }
		
		//AheadLiteral
		public RuleCall getAheadAheadLiteralEnumRuleCall_2_0() { return cAheadAheadLiteralEnumRuleCall_2_0; }
	}
	public class NormalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.NormalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNormalExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cLiteralAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLiteralNormalExpressionLiteralEnumRuleCall_1_0 = (RuleCall)cLiteralAssignment_1.eContents().get(0);
		
		//NormalExpression Expression:
		//	{NormalExpression} literal=NormalExpressionLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//{NormalExpression} literal=NormalExpressionLiteral
		public Group getGroup() { return cGroup; }
		
		//{NormalExpression}
		public Action getNormalExpressionAction_0() { return cNormalExpressionAction_0; }
		
		//literal=NormalExpressionLiteral
		public Assignment getLiteralAssignment_1() { return cLiteralAssignment_1; }
		
		//NormalExpressionLiteral
		public RuleCall getLiteralNormalExpressionLiteralEnumRuleCall_1_0() { return cLiteralNormalExpressionLiteralEnumRuleCall_1_0; }
	}
	public class CommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.Comment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCommentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommandRL_COMMENTTerminalRuleCall_1_0 = (RuleCall)cCommandAssignment_1.eContents().get(0);
		
		//Comment:
		//	{Comment} command=RL_COMMENT;
		@Override public ParserRule getRule() { return rule; }
		
		//{Comment} command=RL_COMMENT
		public Group getGroup() { return cGroup; }
		
		//{Comment}
		public Action getCommentAction_0() { return cCommentAction_0; }
		
		//command=RL_COMMENT
		public Assignment getCommandAssignment_1() { return cCommandAssignment_1; }
		
		//RL_COMMENT
		public RuleCall getCommandRL_COMMENTTerminalRuleCall_1_0() { return cCommandRL_COMMENTTerminalRuleCall_1_0; }
	}
	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIfStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cDoKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cCommandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCommandStatementParserRuleCall_4_0 = (RuleCall)cCommandAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cDoKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cCommand2Assignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cCommand2StatementParserRuleCall_5_2_0 = (RuleCall)cCommand2Assignment_5_2.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//IfStatement:
		//	{IfStatement}
		//	'if' condition=Expression 'do'
		//	command+=Statement* ('else' 'do' command2+=Statement*)?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//{IfStatement} 'if' condition=Expression 'do' command+=Statement* ('else' 'do' command2+=Statement*)? 'end'
		public Group getGroup() { return cGroup; }
		
		//{IfStatement}
		public Action getIfStatementAction_0() { return cIfStatementAction_0; }
		
		//'if'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }
		
		//'do'
		public Keyword getDoKeyword_3() { return cDoKeyword_3; }
		
		//command+=Statement*
		public Assignment getCommandAssignment_4() { return cCommandAssignment_4; }
		
		//Statement
		public RuleCall getCommandStatementParserRuleCall_4_0() { return cCommandStatementParserRuleCall_4_0; }
		
		//('else' 'do' command2+=Statement*)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'else'
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }
		
		//'do'
		public Keyword getDoKeyword_5_1() { return cDoKeyword_5_1; }
		
		//command2+=Statement*
		public Assignment getCommand2Assignment_5_2() { return cCommand2Assignment_5_2; }
		
		//Statement
		public RuleCall getCommand2StatementParserRuleCall_5_2_0() { return cCommand2StatementParserRuleCall_5_2_0; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWhileStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cDoKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cCommandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCommandStatementParserRuleCall_4_0 = (RuleCall)cCommandAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//WhileStatement:
		//	{WhileStatement}
		//	'while' condition=Expression 'do'
		//	command+=Statement*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//{WhileStatement} 'while' condition=Expression 'do' command+=Statement* 'end'
		public Group getGroup() { return cGroup; }
		
		//{WhileStatement}
		public Action getWhileStatementAction_0() { return cWhileStatementAction_0; }
		
		//'while'
		public Keyword getWhileKeyword_1() { return cWhileKeyword_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }
		
		//'do'
		public Keyword getDoKeyword_3() { return cDoKeyword_3; }
		
		//command+=Statement*
		public Assignment getCommandAssignment_4() { return cCommandAssignment_4; }
		
		//Statement
		public RuleCall getCommandStatementParserRuleCall_4_0() { return cCommandStatementParserRuleCall_4_0; }
		
		//'end'
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
	}
	public class RepeatStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.RepeatStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRepeatStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRepeatKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionINTTerminalRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cTimesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cCommandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCommandStatementParserRuleCall_4_0 = (RuleCall)cCommandAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//RepeatStatement:
		//	{RepeatStatement}
		//	'repeat' condition=INT 'times'
		//	command+=Statement*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//{RepeatStatement} 'repeat' condition=INT 'times' command+=Statement* 'end'
		public Group getGroup() { return cGroup; }
		
		//{RepeatStatement}
		public Action getRepeatStatementAction_0() { return cRepeatStatementAction_0; }
		
		//'repeat'
		public Keyword getRepeatKeyword_1() { return cRepeatKeyword_1; }
		
		//condition=INT
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }
		
		//INT
		public RuleCall getConditionINTTerminalRuleCall_2_0() { return cConditionINTTerminalRuleCall_2_0; }
		
		//'times'
		public Keyword getTimesKeyword_3() { return cTimesKeyword_3; }
		
		//command+=Statement*
		public Assignment getCommandAssignment_4() { return cCommandAssignment_4; }
		
		//Statement
		public RuleCall getCommandStatementParserRuleCall_4_0() { return cCommandStatementParserRuleCall_4_0; }
		
		//'end'
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
	}
	public class TraceCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.TraceCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTraceCommandAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTraceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCommandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCommandSTRINGTerminalRuleCall_2_0 = (RuleCall)cCommandAssignment_2.eContents().get(0);
		
		//TraceCommand:
		//	{TraceCommand} 'trace' command=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//{TraceCommand} 'trace' command=STRING
		public Group getGroup() { return cGroup; }
		
		//{TraceCommand}
		public Action getTraceCommandAction_0() { return cTraceCommandAction_0; }
		
		//'trace'
		public Keyword getTraceKeyword_1() { return cTraceKeyword_1; }
		
		//command=STRING
		public Assignment getCommandAssignment_2() { return cCommandAssignment_2; }
		
		//STRING
		public RuleCall getCommandSTRINGTerminalRuleCall_2_0() { return cCommandSTRINGTerminalRuleCall_2_0; }
	}
	public class AtomicCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.AtomicCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtomicCommandAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommandCommandLiteralEnumRuleCall_1_0 = (RuleCall)cCommandAssignment_1.eContents().get(0);
		
		//AtomicCommand:
		//	{AtomicCommand} command=CommandLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//{AtomicCommand} command=CommandLiteral
		public Group getGroup() { return cGroup; }
		
		//{AtomicCommand}
		public Action getAtomicCommandAction_0() { return cAtomicCommandAction_0; }
		
		//command=CommandLiteral
		public Assignment getCommandAssignment_1() { return cCommandAssignment_1; }
		
		//CommandLiteral
		public RuleCall getCommandCommandLiteralEnumRuleCall_1_0() { return cCommandCommandLiteralEnumRuleCall_1_0; }
	}
	public class ConstructionStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.ConstructionStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstructionStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommandGridLiteralEnumRuleCall_1_0 = (RuleCall)cCommandAssignment_1.eContents().get(0);
		private final Keyword cAtKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRowKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cXAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cXINTTerminalRuleCall_4_0 = (RuleCall)cXAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cColKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cYAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cYINTTerminalRuleCall_7_0 = (RuleCall)cYAssignment_7.eContents().get(0);
		
		//ConstructionStatement:
		//	{ConstructionStatement} command=GridLiteral 'at' 'row:' x=INT "," 'col:' y=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//{ConstructionStatement} command=GridLiteral 'at' 'row:' x=INT "," 'col:' y=INT
		public Group getGroup() { return cGroup; }
		
		//{ConstructionStatement}
		public Action getConstructionStatementAction_0() { return cConstructionStatementAction_0; }
		
		//command=GridLiteral
		public Assignment getCommandAssignment_1() { return cCommandAssignment_1; }
		
		//GridLiteral
		public RuleCall getCommandGridLiteralEnumRuleCall_1_0() { return cCommandGridLiteralEnumRuleCall_1_0; }
		
		//'at'
		public Keyword getAtKeyword_2() { return cAtKeyword_2; }
		
		//'row:'
		public Keyword getRowKeyword_3() { return cRowKeyword_3; }
		
		//x=INT
		public Assignment getXAssignment_4() { return cXAssignment_4; }
		
		//INT
		public RuleCall getXINTTerminalRuleCall_4_0() { return cXINTTerminalRuleCall_4_0; }
		
		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//'col:'
		public Keyword getColKeyword_6() { return cColKeyword_6; }
		
		//y=INT
		public Assignment getYAssignment_7() { return cYAssignment_7; }
		
		//INT
		public RuleCall getYINTTerminalRuleCall_7_0() { return cYINTTerminalRuleCall_7_0; }
	}
	
	public class OperatorLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.OperatorLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAndEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAndAndKeyword_0_0 = (Keyword)cAndEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOrEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOrOrKeyword_1_0 = (Keyword)cOrEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum OperatorLiteral:
		//	and | or;
		public EnumRule getRule() { return rule; }
		
		//and | or
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//and
		public EnumLiteralDeclaration getAndEnumLiteralDeclaration_0() { return cAndEnumLiteralDeclaration_0; }
		
		//'and'
		public Keyword getAndAndKeyword_0_0() { return cAndAndKeyword_0_0; }
		
		//or
		public EnumLiteralDeclaration getOrEnumLiteralDeclaration_1() { return cOrEnumLiteralDeclaration_1; }
		
		//'or'
		public Keyword getOrOrKeyword_1_0() { return cOrOrKeyword_1_0; }
	}
	public class HeadingLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.HeadingLiteral");
		private final EnumLiteralDeclaration cHeadingEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cHeadingHeadingKeyword_0 = (Keyword)cHeadingEnumLiteralDeclaration.eContents().get(0);
		
		//enum HeadingLiteral:
		//	heading;
		public EnumRule getRule() { return rule; }
		
		//heading
		public EnumLiteralDeclaration getHeadingEnumLiteralDeclaration() { return cHeadingEnumLiteralDeclaration; }
		
		//'heading'
		public Keyword getHeadingHeadingKeyword_0() { return cHeadingHeadingKeyword_0; }
	}
	public class DirectionLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.DirectionLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNorthEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNorthNorthKeyword_0_0 = (Keyword)cNorthEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSouthEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSouthSouthKeyword_1_0 = (Keyword)cSouthEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEastEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEastEastKeyword_2_0 = (Keyword)cEastEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cWestEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cWestWestKeyword_3_0 = (Keyword)cWestEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum DirectionLiteral:
		//	north | south | east | west;
		public EnumRule getRule() { return rule; }
		
		//north | south | east | west
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//north
		public EnumLiteralDeclaration getNorthEnumLiteralDeclaration_0() { return cNorthEnumLiteralDeclaration_0; }
		
		//'north'
		public Keyword getNorthNorthKeyword_0_0() { return cNorthNorthKeyword_0_0; }
		
		//south
		public EnumLiteralDeclaration getSouthEnumLiteralDeclaration_1() { return cSouthEnumLiteralDeclaration_1; }
		
		//'south'
		public Keyword getSouthSouthKeyword_1_0() { return cSouthSouthKeyword_1_0; }
		
		//east
		public EnumLiteralDeclaration getEastEnumLiteralDeclaration_2() { return cEastEnumLiteralDeclaration_2; }
		
		//'east'
		public Keyword getEastEastKeyword_2_0() { return cEastEastKeyword_2_0; }
		
		//west
		public EnumLiteralDeclaration getWestEnumLiteralDeclaration_3() { return cWestEnumLiteralDeclaration_3; }
		
		//'west'
		public Keyword getWestWestKeyword_3_0() { return cWestWestKeyword_3_0; }
	}
	public class WallLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.WallLiteral");
		private final EnumLiteralDeclaration cWallEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cWallWallKeyword_0 = (Keyword)cWallEnumLiteralDeclaration.eContents().get(0);
		
		//enum WallLiteral:
		//	wall;
		public EnumRule getRule() { return rule; }
		
		//wall
		public EnumLiteralDeclaration getWallEnumLiteralDeclaration() { return cWallEnumLiteralDeclaration; }
		
		//'wall'
		public Keyword getWallWallKeyword_0() { return cWallWallKeyword_0; }
	}
	public class AheadLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.AheadLiteral");
		private final EnumLiteralDeclaration cAheadEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cAheadAheadKeyword_0 = (Keyword)cAheadEnumLiteralDeclaration.eContents().get(0);
		
		//enum AheadLiteral:
		//	ahead;
		public EnumRule getRule() { return rule; }
		
		//ahead
		public EnumLiteralDeclaration getAheadEnumLiteralDeclaration() { return cAheadEnumLiteralDeclaration; }
		
		//'ahead'
		public Keyword getAheadAheadKeyword_0() { return cAheadAheadKeyword_0; }
	}
	public class NormalExpressionLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.NormalExpressionLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFullEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFullFullKeyword_0_0 = (Keyword)cFullEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMarkEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMarkMarkKeyword_1_0 = (Keyword)cMarkEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum NormalExpressionLiteral:
		//	full | mark;
		public EnumRule getRule() { return rule; }
		
		//full | mark
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//full
		public EnumLiteralDeclaration getFullEnumLiteralDeclaration_0() { return cFullEnumLiteralDeclaration_0; }
		
		//'full'
		public Keyword getFullFullKeyword_0_0() { return cFullFullKeyword_0_0; }
		
		//mark
		public EnumLiteralDeclaration getMarkEnumLiteralDeclaration_1() { return cMarkEnumLiteralDeclaration_1; }
		
		//'mark'
		public Keyword getMarkMarkKeyword_1_0() { return cMarkMarkKeyword_1_0; }
	}
	public class TraceLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.TraceLiteral");
		private final EnumLiteralDeclaration cTraceEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cTraceTraceKeyword_0 = (Keyword)cTraceEnumLiteralDeclaration.eContents().get(0);
		
		//enum TraceLiteral:
		//	trace;
		public EnumRule getRule() { return rule; }
		
		//trace
		public EnumLiteralDeclaration getTraceEnumLiteralDeclaration() { return cTraceEnumLiteralDeclaration; }
		
		//'trace'
		public Keyword getTraceTraceKeyword_0() { return cTraceTraceKeyword_0; }
	}
	public class CommandLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.CommandLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cStepEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cStepStepKeyword_0_0 = (Keyword)cStepEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cTurnLeftEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cTurnLeftTurnLeftKeyword_1_0 = (Keyword)cTurnLeftEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDropEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDropDropKeyword_2_0 = (Keyword)cDropEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cPickEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cPickPickKeyword_3_0 = (Keyword)cPickEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum CommandLiteral:
		//	step | turnLeft | drop | pick;
		public EnumRule getRule() { return rule; }
		
		//step | turnLeft | drop | pick
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//step
		public EnumLiteralDeclaration getStepEnumLiteralDeclaration_0() { return cStepEnumLiteralDeclaration_0; }
		
		//'step'
		public Keyword getStepStepKeyword_0_0() { return cStepStepKeyword_0_0; }
		
		//turnLeft
		public EnumLiteralDeclaration getTurnLeftEnumLiteralDeclaration_1() { return cTurnLeftEnumLiteralDeclaration_1; }
		
		//'turnLeft'
		public Keyword getTurnLeftTurnLeftKeyword_1_0() { return cTurnLeftTurnLeftKeyword_1_0; }
		
		//drop
		public EnumLiteralDeclaration getDropEnumLiteralDeclaration_2() { return cDropEnumLiteralDeclaration_2; }
		
		//'drop'
		public Keyword getDropDropKeyword_2_0() { return cDropDropKeyword_2_0; }
		
		//pick
		public EnumLiteralDeclaration getPickEnumLiteralDeclaration_3() { return cPickEnumLiteralDeclaration_3; }
		
		//'pick'
		public Keyword getPickPickKeyword_3_0() { return cPickPickKeyword_3_0; }
	}
	public class GridLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.GridLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBuildWallEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBuildWallBuildWallKeyword_0_0 = (Keyword)cBuildWallEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDestroyWallEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDestroyWallDestroyWallKeyword_1_0 = (Keyword)cDestroyWallEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPickMarkEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPickMarkPickMarkKeyword_2_0 = (Keyword)cPickMarkEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cDropMarkEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cDropMarkDropMarkKeyword_3_0 = (Keyword)cDropMarkEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum GridLiteral:
		//	buildWall | destroyWall | pickMark | dropMark;
		public EnumRule getRule() { return rule; }
		
		//buildWall | destroyWall | pickMark | dropMark
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//buildWall
		public EnumLiteralDeclaration getBuildWallEnumLiteralDeclaration_0() { return cBuildWallEnumLiteralDeclaration_0; }
		
		//'buildWall'
		public Keyword getBuildWallBuildWallKeyword_0_0() { return cBuildWallBuildWallKeyword_0_0; }
		
		//destroyWall
		public EnumLiteralDeclaration getDestroyWallEnumLiteralDeclaration_1() { return cDestroyWallEnumLiteralDeclaration_1; }
		
		//'destroyWall'
		public Keyword getDestroyWallDestroyWallKeyword_1_0() { return cDestroyWallDestroyWallKeyword_1_0; }
		
		//pickMark
		public EnumLiteralDeclaration getPickMarkEnumLiteralDeclaration_2() { return cPickMarkEnumLiteralDeclaration_2; }
		
		//'pickMark'
		public Keyword getPickMarkPickMarkKeyword_2_0() { return cPickMarkPickMarkKeyword_2_0; }
		
		//dropMark
		public EnumLiteralDeclaration getDropMarkEnumLiteralDeclaration_3() { return cDropMarkEnumLiteralDeclaration_3; }
		
		//'dropMark'
		public Keyword getDropMarkDropMarkKeyword_3_0() { return cDropMarkDropMarkKeyword_3_0; }
	}
	
	private final ScriptElements pScript;
	private final StatementElements pStatement;
	private final ExpressionElements pExpression;
	private final NegatedExpressionElements pNegatedExpression;
	private final BinaryExpressionElements pBinaryExpression;
	private final HeadingExpressionElements pHeadingExpression;
	private final WallAheadExpressionElements pWallAheadExpression;
	private final NormalExpressionElements pNormalExpression;
	private final TerminalRule tRL_COMMENT;
	private final CommentElements pComment;
	private final IfStatementElements pIfStatement;
	private final WhileStatementElements pWhileStatement;
	private final RepeatStatementElements pRepeatStatement;
	private final TraceCommandElements pTraceCommand;
	private final AtomicCommandElements pAtomicCommand;
	private final ConstructionStatementElements pConstructionStatement;
	private final OperatorLiteralElements eOperatorLiteral;
	private final HeadingLiteralElements eHeadingLiteral;
	private final DirectionLiteralElements eDirectionLiteral;
	private final WallLiteralElements eWallLiteral;
	private final AheadLiteralElements eAheadLiteral;
	private final NormalExpressionLiteralElements eNormalExpressionLiteral;
	private final TraceLiteralElements eTraceLiteral;
	private final CommandLiteralElements eCommandLiteral;
	private final GridLiteralElements eGridLiteral;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public RobotGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pScript = new ScriptElements();
		this.pStatement = new StatementElements();
		this.pExpression = new ExpressionElements();
		this.pNegatedExpression = new NegatedExpressionElements();
		this.pBinaryExpression = new BinaryExpressionElements();
		this.pHeadingExpression = new HeadingExpressionElements();
		this.pWallAheadExpression = new WallAheadExpressionElements();
		this.pNormalExpression = new NormalExpressionElements();
		this.tRL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "nl.tue.robot.Robot.RL_COMMENT");
		this.pComment = new CommentElements();
		this.pIfStatement = new IfStatementElements();
		this.pWhileStatement = new WhileStatementElements();
		this.pRepeatStatement = new RepeatStatementElements();
		this.pTraceCommand = new TraceCommandElements();
		this.pAtomicCommand = new AtomicCommandElements();
		this.pConstructionStatement = new ConstructionStatementElements();
		this.eOperatorLiteral = new OperatorLiteralElements();
		this.eHeadingLiteral = new HeadingLiteralElements();
		this.eDirectionLiteral = new DirectionLiteralElements();
		this.eWallLiteral = new WallLiteralElements();
		this.eAheadLiteral = new AheadLiteralElements();
		this.eNormalExpressionLiteral = new NormalExpressionLiteralElements();
		this.eTraceLiteral = new TraceLiteralElements();
		this.eCommandLiteral = new CommandLiteralElements();
		this.eGridLiteral = new GridLiteralElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("nl.tue.robot.Robot".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Script:
	//	{Script}
	//	'Script' name=ID 'runs' 'as'
	//	command+=Statement*
	//	'end';
	public ScriptElements getScriptAccess() {
		return pScript;
	}
	
	public ParserRule getScriptRule() {
		return getScriptAccess().getRule();
	}
	
	//Statement:
	//	IfStatement | WhileStatement | RepeatStatement | Comment | TraceCommand | AtomicCommand | ConstructionStatement;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//Expression:
	//	NegatedExpression | BinaryExpression | HeadingExpression | WallAheadExpression | NormalExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//NegatedExpression Expression:
	//	{NegatedExpression}
	//	'not' negatedExpression=Expression;
	public NegatedExpressionElements getNegatedExpressionAccess() {
		return pNegatedExpression;
	}
	
	public ParserRule getNegatedExpressionRule() {
		return getNegatedExpressionAccess().getRule();
	}
	
	//BinaryExpression Expression:
	//	{BinaryExpression}
	//	'(' leftExpression=Expression operator=OperatorLiteral rightExpression=Expression ')';
	public BinaryExpressionElements getBinaryExpressionAccess() {
		return pBinaryExpression;
	}
	
	public ParserRule getBinaryExpressionRule() {
		return getBinaryExpressionAccess().getRule();
	}
	
	//HeadingExpression Expression:
	//	{HeadingExpression} headingLiteral=HeadingLiteral directionLiteral=DirectionLiteral;
	public HeadingExpressionElements getHeadingExpressionAccess() {
		return pHeadingExpression;
	}
	
	public ParserRule getHeadingExpressionRule() {
		return getHeadingExpressionAccess().getRule();
	}
	
	//WallAheadExpression Expression:
	//	{WallAheadExpression} wall=WallLiteral ahead=AheadLiteral;
	public WallAheadExpressionElements getWallAheadExpressionAccess() {
		return pWallAheadExpression;
	}
	
	public ParserRule getWallAheadExpressionRule() {
		return getWallAheadExpressionAccess().getRule();
	}
	
	//NormalExpression Expression:
	//	{NormalExpression} literal=NormalExpressionLiteral;
	public NormalExpressionElements getNormalExpressionAccess() {
		return pNormalExpression;
	}
	
	public ParserRule getNormalExpressionRule() {
		return getNormalExpressionAccess().getRule();
	}
	
	//terminal RL_COMMENT:
	//	'#' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getRL_COMMENTRule() {
		return tRL_COMMENT;
	}
	
	//Comment:
	//	{Comment} command=RL_COMMENT;
	public CommentElements getCommentAccess() {
		return pComment;
	}
	
	public ParserRule getCommentRule() {
		return getCommentAccess().getRule();
	}
	
	//IfStatement:
	//	{IfStatement}
	//	'if' condition=Expression 'do'
	//	command+=Statement* ('else' 'do' command2+=Statement*)?
	//	'end';
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}
	
	//WhileStatement:
	//	{WhileStatement}
	//	'while' condition=Expression 'do'
	//	command+=Statement*
	//	'end';
	public WhileStatementElements getWhileStatementAccess() {
		return pWhileStatement;
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}
	
	//RepeatStatement:
	//	{RepeatStatement}
	//	'repeat' condition=INT 'times'
	//	command+=Statement*
	//	'end';
	public RepeatStatementElements getRepeatStatementAccess() {
		return pRepeatStatement;
	}
	
	public ParserRule getRepeatStatementRule() {
		return getRepeatStatementAccess().getRule();
	}
	
	//TraceCommand:
	//	{TraceCommand} 'trace' command=STRING;
	public TraceCommandElements getTraceCommandAccess() {
		return pTraceCommand;
	}
	
	public ParserRule getTraceCommandRule() {
		return getTraceCommandAccess().getRule();
	}
	
	//AtomicCommand:
	//	{AtomicCommand} command=CommandLiteral;
	public AtomicCommandElements getAtomicCommandAccess() {
		return pAtomicCommand;
	}
	
	public ParserRule getAtomicCommandRule() {
		return getAtomicCommandAccess().getRule();
	}
	
	//ConstructionStatement:
	//	{ConstructionStatement} command=GridLiteral 'at' 'row:' x=INT "," 'col:' y=INT;
	public ConstructionStatementElements getConstructionStatementAccess() {
		return pConstructionStatement;
	}
	
	public ParserRule getConstructionStatementRule() {
		return getConstructionStatementAccess().getRule();
	}
	
	//enum OperatorLiteral:
	//	and | or;
	public OperatorLiteralElements getOperatorLiteralAccess() {
		return eOperatorLiteral;
	}
	
	public EnumRule getOperatorLiteralRule() {
		return getOperatorLiteralAccess().getRule();
	}
	
	//enum HeadingLiteral:
	//	heading;
	public HeadingLiteralElements getHeadingLiteralAccess() {
		return eHeadingLiteral;
	}
	
	public EnumRule getHeadingLiteralRule() {
		return getHeadingLiteralAccess().getRule();
	}
	
	//enum DirectionLiteral:
	//	north | south | east | west;
	public DirectionLiteralElements getDirectionLiteralAccess() {
		return eDirectionLiteral;
	}
	
	public EnumRule getDirectionLiteralRule() {
		return getDirectionLiteralAccess().getRule();
	}
	
	//enum WallLiteral:
	//	wall;
	public WallLiteralElements getWallLiteralAccess() {
		return eWallLiteral;
	}
	
	public EnumRule getWallLiteralRule() {
		return getWallLiteralAccess().getRule();
	}
	
	//enum AheadLiteral:
	//	ahead;
	public AheadLiteralElements getAheadLiteralAccess() {
		return eAheadLiteral;
	}
	
	public EnumRule getAheadLiteralRule() {
		return getAheadLiteralAccess().getRule();
	}
	
	//enum NormalExpressionLiteral:
	//	full | mark;
	public NormalExpressionLiteralElements getNormalExpressionLiteralAccess() {
		return eNormalExpressionLiteral;
	}
	
	public EnumRule getNormalExpressionLiteralRule() {
		return getNormalExpressionLiteralAccess().getRule();
	}
	
	//enum TraceLiteral:
	//	trace;
	public TraceLiteralElements getTraceLiteralAccess() {
		return eTraceLiteral;
	}
	
	public EnumRule getTraceLiteralRule() {
		return getTraceLiteralAccess().getRule();
	}
	
	//enum CommandLiteral:
	//	step | turnLeft | drop | pick;
	public CommandLiteralElements getCommandLiteralAccess() {
		return eCommandLiteral;
	}
	
	public EnumRule getCommandLiteralRule() {
		return getCommandLiteralAccess().getRule();
	}
	
	//enum GridLiteral:
	//	buildWall | destroyWall | pickMark | dropMark;
	public GridLiteralElements getGridLiteralAccess() {
		return eGridLiteral;
	}
	
	public EnumRule getGridLiteralRule() {
		return getGridLiteralAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
